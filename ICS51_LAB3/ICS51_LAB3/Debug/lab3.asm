; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.30501.0 

	TITLE	C:\Users\Brian\Documents\Dropbox\Projects\ICS51_LAB3\ICS51_LAB3\lab3.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_yourName
PUBLIC	??_C@_0L@NMHEFPEJ@Brian?5Dinh?$AA@		; `string'
PUBLIC	_yourStudentID
PUBLIC	??_C@_08LHMEPANE@34546266?$AA@			; `string'
;	COMDAT ??_C@_08LHMEPANE@34546266?$AA@
CONST	SEGMENT
??_C@_08LHMEPANE@34546266?$AA@ DB '34546266', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NMHEFPEJ@Brian?5Dinh?$AA@
CONST	SEGMENT
??_C@_0L@NMHEFPEJ@Brian?5Dinh?$AA@ DB 'Brian Dinh', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
_yourName DD	FLAT:??_C@_0L@NMHEFPEJ@Brian?5Dinh?$AA@
_yourStudentID DD FLAT:??_C@_08LHMEPANE@34546266?$AA@
_DATA	ENDS
PUBLIC	_findMinIndex
PUBLIC	_selectionSort
PUBLIC	_recFactorial
PUBLIC	_factorial
PUBLIC	_performOperation
PUBLIC	_vectorOperations
PUBLIC	_changeCase
PUBLIC	_fibonacci
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\brian\documents\dropbox\projects\ics51_lab3\ics51_lab3\lab3.c
;	COMDAT _fibonacci
_TEXT	SEGMENT
_n$ = 8							; size = 4
_fibonacci PROC						; COMDAT

; 511  : 
; 512  : // C code to be converted to x86 assembly
; 513  : /*
; 514  : 	if (n < 2) 
; 515  : 		return 1;
; 516  : 	else 
; 517  : 		return fibonacci(n - 1) + fibonacci(n - 2);
; 518  : */
; 519  : 
; 520  : 	__asm{
; 521  : 			// BEGIN YOUR CODE HERE
; 522  : 
; 523  : 		push ebp

	push	ebp

; 524  : 		mov ebp, esp

	mov	ebp, esp

; 525  : 		push ebx

	push	ebx

; 526  : 		push esi

	push	esi

; 527  : 		push edi

	push	edi

; 528  : 
; 529  : 		mov eax, n

	mov	eax, DWORD PTR _n$[ebp]

; 530  : 		cmp eax, 2

	cmp	eax, 2

; 531  : 		jae A

	jae	SHORT $A$3

; 532  : 
; 533  : 		mov eax, 1

	mov	eax, 1

; 534  : 		jmp B

	jmp	SHORT $B$4
$A$3:

; 535  : 
; 536  : 	A:
; 537  : 		mov eax, n

	mov	eax, DWORD PTR _n$[ebp]

; 538  : 		sub eax, 1

	sub	eax, 1

; 539  : 		push eax

	push	eax

; 540  : 		call fibonacci

	call	_fibonacci

; 541  : 		add esp, 4

	add	esp, 4

; 542  : 
; 543  : 		mov esi, eax

	mov	esi, eax

; 544  : 		mov ebx, n

	mov	ebx, DWORD PTR _n$[ebp]

; 545  : 		sub ebx, 2

	sub	ebx, 2

; 546  : 		push ebx

	push	ebx

; 547  : 		call fibonacci

	call	_fibonacci

; 548  : 		add esp, 4

	add	esp, 4

; 549  : 		add eax, esi

	add	eax, esi
$B$4:

; 550  : 
; 551  : 	B:
; 552  : 		pop edi

	pop	edi

; 553  : 		pop esi

	pop	esi

; 554  : 		pop ebx

	pop	ebx

; 555  : 		mov esp, ebp

	mov	esp, ebp

; 556  : 		pop ebp

	pop	ebp

; 557  : 
; 558  : 
; 559  : 			// END YOUR CODE HERE
; 560  : 			ret

	ret	0
_fibonacci ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\brian\documents\dropbox\projects\ics51_lab3\ics51_lab3\lab3.c
;	COMDAT _changeCase
_TEXT	SEGMENT
_char_array$ = 8					; size = 4
_array_size$ = 12					; size = 4
_changeCase PROC					; COMDAT

; 462  : void changeCase (char char_array[], int array_size ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 463  : 
; 464  : 	__asm{
; 465  : 			// BEGIN YOUR CODE HERE
; 466  : 		mov edx, char_array

	mov	edx, DWORD PTR _char_array$[ebp]

; 467  : 		mov ebx, array_size

	mov	ebx, DWORD PTR _array_size$[ebp]

; 468  : 		mov ecx, 0

	mov	ecx, 0
$Begin$3:

; 469  : 
; 470  : 	Begin:
; 471  : 		cmp ecx, ebx

	cmp	ecx, ebx

; 472  : 		jge End

	jge	SHORT $End$4

; 473  : 
; 474  : 		mov al, byte ptr[edx+ecx*1]

	mov	al, BYTE PTR [edx+ecx]

; 475  : 		cmp al, 64

	cmp	al, 64					; 00000040H

; 476  : 		jle B

	jle	SHORT $B$5

; 477  : 
; 478  : 		cmp al, 91

	cmp	al, 91					; 0000005bH

; 479  : 		jge A

	jge	SHORT $A$6

; 480  : 
; 481  : 		add byte ptr [edx+ecx*1], 32

	add	BYTE PTR [edx+ecx], 32			; 00000020H

; 482  : 		jmp B

	jmp	SHORT $B$5
$A$6:

; 483  : 
; 484  : 	A:
; 485  : 		cmp al, 123

	cmp	al, 123					; 0000007bH

; 486  : 		jge B

	jge	SHORT $B$5

; 487  : 
; 488  : 		sub byte ptr[edx+ecx*1], 32

	sub	BYTE PTR [edx+ecx], 32			; 00000020H
$B$5:

; 489  : 
; 490  : 	B:
; 491  : 		inc ecx

	inc	ecx

; 492  : 		jmp Begin

	jmp	SHORT $Begin$3
$End$4:

; 493  : 
; 494  : 	End:
; 495  : 
; 496  : 			// END YOUR CODE HERE
; 497  : 	}
; 498  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_changeCase ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\brian\documents\dropbox\projects\ics51_lab3\ics51_lab3\lab3.c
;	COMDAT _vectorOperations
_TEXT	SEGMENT
_number_of_elements$ = 8				; size = 4
_first_array$ = 12					; size = 4
_second_array$ = 16					; size = 4
_operation_array$ = 20					; size = 4
_output_array$ = 24					; size = 4
_vectorOperations PROC					; COMDAT

; 393  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 394  : // C code to be converted to x86 assembly
; 395  : /*
; 396  : 	int i;
; 397  : 	for (i=0; i<number_of_elements; i++)
; 398  : 	{
; 399  : 		output_array[i] = performOperation(operation_array[i], first_array[i], second_array[i]);
; 400  : 	}
; 401  : */
; 402  : 
; 403  : 	__asm {
; 404  : 			// BEGIN YOUR CODE HERE
; 405  : 
; 406  : 		mov ebx, 0 // i

	mov	ebx, 0
$Begin$3:

; 407  : 
; 408  : 	
; 409  : 	Begin:
; 410  : 		cmp ebx, number_of_elements

	cmp	ebx, DWORD PTR _number_of_elements$[ebp]

; 411  : 		jge End

	jge	SHORT $End$4

; 412  : 
; 413  : 		mov ecx, second_array

	mov	ecx, DWORD PTR _second_array$[ebp]

; 414  : 		mov edx, dword ptr[ecx+ebx*4]

	mov	edx, DWORD PTR [ecx+ebx*4]

; 415  : 		push edx

	push	edx

; 416  : 
; 417  : 		mov ecx, first_array

	mov	ecx, DWORD PTR _first_array$[ebp]

; 418  : 		mov edx, dword ptr[ecx+ebx*4]

	mov	edx, DWORD PTR [ecx+ebx*4]

; 419  : 		push edx

	push	edx

; 420  : 
; 421  : 		mov ecx, operation_array

	mov	ecx, DWORD PTR _operation_array$[ebp]

; 422  : 		mov edx, dword ptr[ecx+ebx*4]

	mov	edx, DWORD PTR [ecx+ebx*4]

; 423  : 		push edx

	push	edx

; 424  : 
; 425  : 		call performOperation

	call	_performOperation

; 426  : 		add esp, 12

	add	esp, 12					; 0000000cH

; 427  : 		mov ecx, ebx

	mov	ecx, ebx

; 428  : 		mov edx, output_array

	mov	edx, DWORD PTR _output_array$[ebp]

; 429  : 		mov dword ptr[edx+ecx*4], eax

	mov	DWORD PTR [edx+ecx*4], eax

; 430  : 
; 431  : 		add ebx, 1

	add	ebx, 1

; 432  : 		jmp Begin

	jmp	SHORT $Begin$3
$End$4:

; 433  : 
; 434  : 	End:
; 435  : 
; 436  : 			// END YOUR CODE HERE
; 437  : 	}
; 438  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_vectorOperations ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\brian\documents\dropbox\projects\ics51_lab3\ics51_lab3\lab3.c
;	COMDAT _performOperation
_TEXT	SEGMENT
_operation$ = 8						; size = 4
_first$ = 12						; size = 4
_second$ = 16						; size = 4
_performOperation PROC					; COMDAT

; 301  : 
; 302  : // C code to be converted to x86 assembly
; 303  : /*
; 304  : 	if (operation==0) 
; 305  : 		return first + second;
; 306  : 	else if (operation==1)
; 307  : 		return first - second;
; 308  : 	else if (operation==2)
; 309  : 		return (first > second)? first : second;
; 310  : 	else if (operation==3)
; 311  : 		return (first < second)? first : second;
; 312  : 	else
; 313  : 		return first;
; 314  : */
; 315  : 
; 316  : 	__asm {
; 317  : 			// BEGIN YOUR CODE HERE
; 318  : 
; 319  : 		push ebp

	push	ebp

; 320  : 		mov ebp, esp

	mov	ebp, esp

; 321  : 		push ebx

	push	ebx

; 322  : 		push esi

	push	esi

; 323  : 		push edi

	push	edi

; 324  : 
; 325  : 	// Op 0
; 326  : 		mov eax, operation

	mov	eax, DWORD PTR _operation$[ebp]

; 327  : 		cmp eax, 0

	cmp	eax, 0

; 328  : 		jne Op1

	jne	SHORT $Op1$3

; 329  : 
; 330  : 		mov eax, first

	mov	eax, DWORD PTR _first$[ebp]

; 331  : 		add eax, second

	add	eax, DWORD PTR _second$[ebp]

; 332  : 		jmp End

	jmp	SHORT $End$4
$Op1$3:

; 333  : 
; 334  : 	Op1:
; 335  : 		mov eax, operation

	mov	eax, DWORD PTR _operation$[ebp]

; 336  : 		cmp eax, 1

	cmp	eax, 1

; 337  : 		jne Op2

	jne	SHORT $Op2$5

; 338  : 
; 339  : 		mov eax, first

	mov	eax, DWORD PTR _first$[ebp]

; 340  : 		sub eax, second

	sub	eax, DWORD PTR _second$[ebp]

; 341  : 		jmp End

	jmp	SHORT $End$4
$Op2$5:

; 342  : 
; 343  : 	Op2:
; 344  : 		mov eax, operation

	mov	eax, DWORD PTR _operation$[ebp]

; 345  : 		cmp eax, 2

	cmp	eax, 2

; 346  : 		jne Op3

	jne	SHORT $Op3$6

; 347  : 
; 348  : 		mov eax, first

	mov	eax, DWORD PTR _first$[ebp]

; 349  : 		cmp eax, second

	cmp	eax, DWORD PTR _second$[ebp]

; 350  : 		jle A

	jle	SHORT $A$7

; 351  : 
; 352  : 		mov eax, first

	mov	eax, DWORD PTR _first$[ebp]

; 353  : 		jmp End

	jmp	SHORT $End$4
$A$7:

; 354  : 
; 355  : 	A:
; 356  : 		mov eax, second

	mov	eax, DWORD PTR _second$[ebp]

; 357  : 		jmp End

	jmp	SHORT $End$4
$Op3$6:

; 358  : 
; 359  : 
; 360  : 	Op3:
; 361  : 		mov eax, operation

	mov	eax, DWORD PTR _operation$[ebp]

; 362  : 		cmp eax, 3

	cmp	eax, 3

; 363  : 		jne retFirst

	jne	SHORT $retFirst$8

; 364  : 
; 365  : 		mov eax, first

	mov	eax, DWORD PTR _first$[ebp]

; 366  : 		cmp eax, second

	cmp	eax, DWORD PTR _second$[ebp]

; 367  : 		jge B

	jge	SHORT $B$9

; 368  : 
; 369  : 		mov eax, first

	mov	eax, DWORD PTR _first$[ebp]

; 370  : 		jmp End

	jmp	SHORT $End$4
$B$9:

; 371  : 
; 372  : 	B:
; 373  : 		mov eax, second

	mov	eax, DWORD PTR _second$[ebp]

; 374  : 		jmp End

	jmp	SHORT $End$4
$retFirst$8:

; 375  : 
; 376  : 	retFirst:
; 377  : 		mov eax, first

	mov	eax, DWORD PTR _first$[ebp]
$End$4:

; 378  : 
; 379  : 	End:
; 380  : 		pop edi

	pop	edi

; 381  : 		pop esi

	pop	esi

; 382  : 		pop ebx

	pop	ebx

; 383  : 		mov esp, ebp

	mov	esp, ebp

; 384  : 		pop ebp

	pop	ebp

; 385  : 			// END YOUR CODE HERE
; 386  : 			ret

	ret	0
_performOperation ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\brian\documents\dropbox\projects\ics51_lab3\ics51_lab3\lab3.c
;	COMDAT _factorial
_TEXT	SEGMENT
_input$ = 8						; size = 4
_output$ = 12						; size = 4
_factorial PROC						; COMDAT

; 258  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 259  : 
; 260  : // C code to be converted to x86 assembly
; 261  : /*
; 262  : 	*output = recFactorial (input);
; 263  : */
; 264  : 
; 265  : 	__asm{
; 266  : 			// BEGIN YOUR CODE HERE
; 267  : 			
; 268  : 		mov eax, input

	mov	eax, DWORD PTR _input$[ebp]

; 269  : 		push eax

	push	eax

; 270  : 		call recFactorial

	call	_recFactorial

; 271  : 		add esp, 4

	add	esp, 4

; 272  : 		mov ecx, output

	mov	ecx, DWORD PTR _output$[ebp]

; 273  : 		mov dword ptr[ecx], eax

	mov	DWORD PTR [ecx], eax

; 274  : 		
; 275  : 
; 276  : 			// END YOUR CODE HERE
; 277  : 	}
; 278  : 
; 279  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_factorial ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\brian\documents\dropbox\projects\ics51_lab3\ics51_lab3\lab3.c
;	COMDAT _recFactorial
_TEXT	SEGMENT
_n$ = 8							; size = 4
_recFactorial PROC					; COMDAT

; 209  : 
; 210  : // C code to be converted to x86 assembly
; 211  : /*
; 212  : 	if (n<=1) 
; 213  : 		return 1;
; 214  : 	else 
; 215  : 		return n * recFactorial(n-1); 
; 216  : */
; 217  : 
; 218  : 	__asm{
; 219  : 			// BEGIN YOUR CODE HERE
; 220  : 		
; 221  : 		push ebp

	push	ebp

; 222  : 		mov ebp, esp

	mov	ebp, esp

; 223  : 		push ebx

	push	ebx

; 224  : 		push esi

	push	esi

; 225  : 		push edi

	push	edi

; 226  : 
; 227  : 		mov eax, n

	mov	eax, DWORD PTR _n$[ebp]

; 228  : 		cmp eax, 1

	cmp	eax, 1

; 229  : 		ja A

	ja	SHORT $A$3

; 230  : 
; 231  : 		mov eax, 1

	mov	eax, 1

; 232  : 		jmp B

	jmp	SHORT $B$4
$A$3:

; 233  : 
; 234  : 	A:
; 235  : 		mov eax, n

	mov	eax, DWORD PTR _n$[ebp]

; 236  : 		sub eax, 1

	sub	eax, 1

; 237  : 		push eax

	push	eax

; 238  : 		call recFactorial

	call	_recFactorial

; 239  : 		add esp, 4

	add	esp, 4

; 240  : 		mov ebx, n

	mov	ebx, DWORD PTR _n$[ebp]

; 241  : 		imul eax, ebx

	imul	eax, ebx
$B$4:

; 242  : 
; 243  : 	B:
; 244  : 		pop edi

	pop	edi

; 245  : 		pop esi

	pop	esi

; 246  : 		pop ebx

	pop	ebx

; 247  : 		mov esp, ebp

	mov	esp, ebp

; 248  : 		pop ebp

	pop	ebp

; 249  : 		ret

	ret	0
_recFactorial ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\brian\documents\dropbox\projects\ics51_lab3\ics51_lab3\lab3.c
;	COMDAT _selectionSort
_TEXT	SEGMENT
_integer_array$ = 8					; size = 4
_array_size$ = 12					; size = 4
_selectionSort PROC					; COMDAT

; 109  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 110  : 
; 111  : // C code to be converted to x86 assembly
; 112  : /*  
; 113  : 	int j;
; 114  : 	int iMin;
; 115  : 	int temp;
; 116  : 
; 117  : 	// advance the position through the entire array //
; 118  : 	// (could do j < n-1 because single element is also min element) //
; 119  : 	for (j = 0; j < array_size-1; j++) {
; 120  : 
; 121  : 		// find the index of min element in the unsorted a[j .. n-1] //
; 122  :  		iMin = findMinIndex (integer_array, j, array_size);
; 123  :  
; 124  : 		if(iMin != j) { // swap values
; 125  : 			temp = integer_array[iMin];
; 126  : 			integer_array[iMin] = integer_array [j];
; 127  : 			integer_array[j] = temp;	
; 128  : 		}
; 129  : 	}
; 130  : */
; 131  : 
; 132  : 	__asm{
; 133  : 			// BEGIN YOUR CODE HERE
; 134  : 
; 135  : 		mov ecx, 0 // j

	mov	ecx, 0
$Begin$3:

; 136  : 
; 137  : 	Begin:
; 138  : 		mov eax, array_size

	mov	eax, DWORD PTR _array_size$[ebp]

; 139  : 		sub eax, 1

	sub	eax, 1

; 140  : 		cmp ecx, eax

	cmp	ecx, eax

; 141  : 		jge End

	jge	SHORT $End$4

; 142  : 		
; 143  : 		mov edx, integer_array

	mov	edx, DWORD PTR _integer_array$[ebp]

; 144  : 		push edx

	push	edx

; 145  : 		push ecx

	push	ecx

; 146  : 		
; 147  : 		mov esi, array_size

	mov	esi, DWORD PTR _array_size$[ebp]

; 148  : 		push esi

	push	esi

; 149  : 		push ecx

	push	ecx

; 150  : 		push edx

	push	edx

; 151  : 		
; 152  : 		call findMinIndex

	call	_findMinIndex

; 153  : 		mov edi, eax

	mov	edi, eax

; 154  : 		add esp, 12

	add	esp, 12					; 0000000cH

; 155  : 		pop ecx

	pop	ecx

; 156  : 		pop edx

	pop	edx

; 157  : 
; 158  : 		cmp edi, ecx

	cmp	edi, ecx

; 159  : 		je A

	je	SHORT $A$5

; 160  : 
; 161  : 		mov eax, integer_array

	mov	eax, DWORD PTR _integer_array$[ebp]

; 162  : 		mov ebx, dword ptr[eax + edi*4]

	mov	ebx, DWORD PTR [eax+edi*4]

; 163  : 		mov edx, dword ptr[eax + ecx*4]

	mov	edx, DWORD PTR [eax+ecx*4]

; 164  : 		mov dword ptr[eax+ecx*4], ebx

	mov	DWORD PTR [eax+ecx*4], ebx

; 165  : 		mov dword ptr[eax+edi*4], edx

	mov	DWORD PTR [eax+edi*4], edx
$A$5:

; 166  : 		
; 167  : 
; 168  : 	A:
; 169  : 		add ecx, 1

	add	ecx, 1

; 170  : 		jmp Begin

	jmp	SHORT $Begin$3
$End$4:

; 171  : 
; 172  : 	End:
; 173  : 
; 174  : 
; 175  : 			// END YOUR CODE HERE
; 176  : 	}
; 177  : 
; 178  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_selectionSort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\brian\documents\dropbox\projects\ics51_lab3\ics51_lab3\lab3.c
;	COMDAT _findMinIndex
_TEXT	SEGMENT
_integer_array$ = 8					; size = 4
_i$ = 12						; size = 4
_j$ = 16						; size = 4
_findMinIndex PROC					; COMDAT

; 54   : 
; 55   : // C code to be converted to x86 assembly
; 56   : /*
; 57   :     int iMin = i;
; 58   :     // test against elements after i and before j to find the smallest 
; 59   :     for ( i ; i < j; i++) {
; 60   :         // if this element is less, then it is the new minimum   
; 61   :         if (integer_array[i] < integer_array[iMin]) {
; 62   :             // found new minimum; remember its index 
; 63   :             iMin = i;
; 64   :         }
; 65   :     }
; 66   : 
; 67   :     return iMin;
; 68   : */
; 69   : 
; 70   : 	__asm{
; 71   : 			// BEGIN YOUR CODE HERE
; 72   : 		push ebp

	push	ebp

; 73   : 		mov ebp, esp

	mov	ebp, esp

; 74   : 		sub esp, 4

	sub	esp, 4

; 75   : 	
; 76   : 		mov esi, i

	mov	esi, DWORD PTR _i$[ebp]

; 77   : 		mov[ebp-4], esi // int iMin = i

	mov	DWORD PTR [ebp-4], esi
$Begin$3:

; 78   : 
; 79   : 	Begin :
; 80   : 		cmp esi, j

	cmp	esi, DWORD PTR _j$[ebp]

; 81   : 		jge End

	jge	SHORT $End$4

; 82   : 
; 83   : 		mov edx, [ebp-4]

	mov	edx, DWORD PTR [ebp-4]

; 84   : 		mov ebx, integer_array

	mov	ebx, DWORD PTR _integer_array$[ebp]

; 85   : 		mov eax, dword ptr[ebx+esi*4]

	mov	eax, DWORD PTR [ebx+esi*4]

; 86   : 		cmp eax, dword ptr[ebx+edx*4]

	cmp	eax, DWORD PTR [ebx+edx*4]

; 87   : 		jge A

	jge	SHORT $A$5

; 88   : 
; 89   : 		mov[ebp-4], esi

	mov	DWORD PTR [ebp-4], esi
$A$5:

; 90   : 
; 91   : 	A:
; 92   : 		add esi, 1

	add	esi, 1

; 93   : 		jmp Begin

	jmp	SHORT $Begin$3
$End$4:

; 94   : 
; 95   : 	End:
; 96   : 		mov eax, [ebp-4]

	mov	eax, DWORD PTR [ebp-4]

; 97   : 		mov esp, ebp

	mov	esp, ebp

; 98   : 		pop ebp

	pop	ebp

; 99   : 
; 100  : 		
; 101  : 
; 102  : 			// END YOUR CODE HERE
; 103  : 			ret

	ret	0
_findMinIndex ENDP
_TEXT	ENDS
END
